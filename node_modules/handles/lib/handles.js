var fs = require('fs');

var arrayUtil = require('./util/array');
var stringUtil = require('./util/string');
var sentenceUtil = require('./util/sentence');

/**
 * Initialise a Handles API Object from previously established data, else start
 * afresh.
 *
 * @param {Object} [data]              - optional JSON data from a previous session
 * @param {Object} [options]           - optional options (tee-hee) that can be configured to tweak Handle's behaviour
 * @param {Object} [options.stopWords] - words to cut out from messages in lower case
 * @constructor
 */
function Handles (data, options)
{
	this.data = data || {};

	this.options = options || {};
	this.options.stopWords = this.options.stopWords || exports.DEFAULT_STOP_WORDS;

	this.session = {};
}

/**
 * Obviously this is a very simple function but is provided so that if
 * implementation of Handles changes, the data can always be accessed the same
 * way.
 *
 * @return {Object} - the data that Handles is using to construct answers
 */
Handles.prototype.getData = function ()
{
	return this.data;
}

/**
* Obviously this is a very simple function but is provided so that if
* implementation of Handles changes, the options can always be accessed the same
* way.
*
* @returns {Object} - the options that Handles is using to construct answers
*/
Handles.prototype.getOptions = function ()
{
	return this.options;
}

/**
* Obviously this is a very simple function but is provided so that if
* implementation of Handles changes, the current session can always be accessed
* the same way.
*
* @returns {Object} - the current session that Handles is using to construct answers
*/
Handles.prototype.getSession = function ()
{
	return this.options;
}

/**
 * Learn how a sentence should be replied to, to help build upon previous
 * knowledge. This should be called after any message in an IRC conversation
 * is sent, with the reply as the new message and the originalMessage as the
 * previous message.
 *
 * @param  {String} originalMessage - the message that was replied to
 * @param  {String} reply           - the reply
 */
Handles.prototype.learn = function (originalMessage, reply)
{
	var originalMessageWords = sentenceUtil.extractWords(originalMessage);
	var replyWords = sentenceUtil.extractWords(reply);

	originalMessageWords = originalMessageWords.filter(this._isValuedWord.bind(this));
	replyWords = replyWords.filter(stringUtil.isNotEmpty);

	if (originalMessageWords.length === 0 || replyWords.length === 0)
	{
		return;
	}

	this.data.words = this.data.words || {};
	this.data.replies = this.data.replies || {};
	this.data.topics = this.data.topics || {};
	
	this.session.topics = this.session.topics || {};

	var replyHash = stringUtil.hash(reply);

	this.data.replies[replyHash] = reply;

	for (var originalMessageWordIndex in originalMessageWords)
	{
		var originalMessageWord = originalMessageWords[originalMessageWordIndex];
		originalMessageWord = originalMessageWord.toLowerCase();

		var hash = stringUtil.hash(originalMessageWord);

		this.data.words[hash] = this.data.words[hash] || {};
		this.data.words[hash][replyHash] = ~~this.data.words[hash][replyHash] + 1; // witchcraft (~~ converts undefined to 0, weirdly)
	}

	for (var topicalHash in this.session.topics)
	{
		if (!this.session.topics.hasOwnProperty(topicalHash))
		{
			continue;
		}

		this.session.topics[topicalHash] *= 0.75;

		if (this.session.topics[topicalHash] <= 0.05)
		{
			delete this.session.topics[topicalHash];
		}
	}

	for (var originalMessageWordIndex in originalMessageWords)
	{
		var originalMessageWord = originalMessageWords[originalMessageWordIndex];
		originalMessageWord = originalMessageWord.toLowerCase();

		var hash = stringUtil.hash(originalMessageWord);

		if (this.session.topics[hash])
		{
			this.session.topics[hash] *= 1.5;
		}
		else
		{
			this.session.topics[hash] = 1;
		}

		this.data.topics[hash] = this.data.topics[hash] || {};
		this.data.topics[hash][replyHash] = (this.data.topics[hash][replyHash] || 0) + this.session.topics[hash];
	}
}

/**
 * Reply to a sentence based on what has been learnt and a few other factors
 * derived from recent conversation.
 *
 * @param  {String} originalMessage - the message to reply to
 * @return {String}                 - the reply, or null if no reply can be assured sensible
 */
Handles.prototype.reply = function (originalMessage)
{
	var originalMessageWords = sentenceUtil.extractWords(originalMessage);
	originalMessageWords = originalMessageWords.filter(this._isValuedWord.bind(this));

	if (originalMessageWords.length === 0)
	{
		return;
	}

	var candidateCount = {};
	var candidateQuantity = {};
	
	this.data.words = this.data.words || {};
	this.data.replies = this.data.replies || {};
	this.data.topics = this.data.topics || {};
	
	this.session.topics = this.session.topics || {};

	for (var originalMessageWordIndex in originalMessageWords)
	{
		var originalMessageWord = originalMessageWords[originalMessageWordIndex];
		originalMessageWord = originalMessageWord.toLowerCase();

		var hash = stringUtil.hash(originalMessageWord);
		var pastWordReplies = this.data.words[hash];

		if (!pastWordReplies)
		{
			continue;
		}

		var totalCount = 0;

		for (reply in pastWordReplies)
		{
			if (!pastWordReplies.hasOwnProperty(reply))
			{
				continue;
			}

			totalCount += pastWordReplies[reply];
		}

		for (reply in pastWordReplies)
		{
			if (!pastWordReplies.hasOwnProperty(reply))
			{
				continue;
			}

			candidateCount[reply] = (candidateCount[reply] || 0) + (pastWordReplies[reply] / totalCount);
			candidateQuantity[reply] = (candidateQuantity[reply] || 0) + 1;
		}
	}

	for (var topicalHash in this.session.topics)
	{
		if (!this.session.topics.hasOwnProperty(topicalHash))
		{
			continue;
		}

		var pastTopicReplies = this.session.topics[topicalHash];
		var totalCount = 0;

		for (reply in pastTopicReplies)
		{
			if (!pastTopicReplies.hasOwnProperty(reply))
			{
				continue;
			}

			totalCount += pastTopicReplies[reply];
		}

		for (reply in pastTopicReplies)
		{
			if (!pastTopicReplies.hasOwnProperty(reply))
			{
				continue;
			}

			candidateCount[reply] = (candidateCount[reply] || 0) + (pastTopicReplies[reply] / (totalCount * 2));
			candidateQuantity[reply] = (candidateQuantity[reply] || 0) + 1;
		}
	}

	var modalCandidates = [];
	var modalCandidatesCount = -Infinity;

	for (var hash in candidateQuantity)
	{
		if (!candidateQuantity.hasOwnProperty(hash))
		{
			continue;
		}

		var quantity = candidateQuantity[hash];

		if (quantity > modalCandidatesCount)
		{
			modalCandidates = [ hash ];
			modalCandidatesCount = quantity;
		}
		else if (quantity === modalCandidatesCount)
		{
			modalCandidates.push(hash);
		}
	}

	if (modalCandidates.length === 0)
	{
		return null;
	}

	var highestCountedModalCandidates = [];
	var highestCountedModalCount = -Infinity;

	// TODO: replace with util function to get highest count
	for (var hash in candidateCount)
	{
		if (!candidateCount.hasOwnProperty(hash))
		{
			continue;
		}

		var count = candidateCount[hash];

		if (count > highestCountedModalCount)
		{
			highestCountedModalCandidates = [ hash ];
			highestCountedModalCount = count;
		}
		else if (count === highestCountedModalCount)
		{
			highestCountedModalCandidates.push(hash);
		}
	}

	return this.data.replies[arrayUtil.randomChoice(highestCountedModalCandidates)];
}

Handles.prototype._isStopWord = function (word)
{
	return this.options.stopWords.indexOf(word.toLowerCase()) !== -1;
}

Handles.prototype._isValuedWord = function (word)
{
	return !this._isStopWord(word);
}

module.exports = exports = Handles;

exports.DEFAULT_STOP_WORDS = fs.readFileSync(__dirname + '/../resources/stopwords_en.txt', 'utf8').trim().split('\n');
